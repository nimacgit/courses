\documentclass[11pt]{article}
%بسم الله الرحمن الرحیم

\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{enumitem,array}
\usepackage{multirow}
\usepackage{blindtext}
\usepackage{tikz}
\usepackage{tkz-graph}
\usepackage{bookmark}
\usetikzlibrary{automata,positioning,arrows, positioning,chains,fit,shapes,calc}
\usepackage[a4paper, margin=0.7in]{geometry}
\usepackage{listings}
\usepackage{clrscode3e}
\usepackage{etex}
\usepackage{hyperref}
\usepackage{etex}

\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
}
\usepackage{xepersian}


\settextfont{HM XNiloofar}
\setlatintextfont{Lucida Sans}
%\setdigitfont{HM XNiloofar}
%\setdigitfont{ParsiDigits}
\defpersianfont\outline[Scale=1]{HM XNiloofar Outline}

\setlength{\parindent}{1.5em}
\setlength{\parskip}{0.9em}
\renewcommand{\baselinestretch}{1.4}


\newcommand{\lecture}[2]{
	%\pagestyle{empty}
	{
		\begin{center}
			\vspace{-1cm}
			\includegraphics[scale=0.15]{Sharif}%\hfill \\[1em]  
		\end{center}
		\vspace{-8mm}
		\begin{center}
			
			\bf
			%\begin{outline} 
			{
				\Large
تمرین۱ هوش مصنوعی 
			}
			%\end{outline} 
			\\
مدرس: دکتر سلیمانی
			\\~
		\date{\today}
		\end{center}
	}\vspace*{-1em}
	\noindent
 #2 \hfill #1
	\vspace{-4mm}
	\rule{\textwidth}{1pt}
	\ \\
}

% example environment
\newenvironment{example}
{\smallskip \noindent \emph{مثال:}}
{\hfill $\boxtimes$ \smallskip}


\newtheorem{theorem}{قضیه}
\newtheorem{proposition}{گزاره}
\newtheorem{claim}{ادعا}
\newtheorem{lemma}{لم}
\newtheorem{corollary}{نتیجه}
\newtheorem{definition}{تعریف} % Use this for non-trivial definitions.


	
\begin{document}
	\lecture{96100114}{نیما بهرنگ}
	\begin{enumerate}

		\item
				\begin{enumerate}
			\item 
			\begin{itemize}
				\item 
				کنترل کننده کیفیت آب:\\
				\lr{P}:
				تشخیص درست کیفیت آب. یعنی تعداد حالاتی که آب سالم است و خروجی دستگاه نیز تایید می کند و حالاتی که آب ناسالم است و دستگاه اعلام ناسالم بودن می کند.
				\lr{E}:
				ورودی آب، تسترهای آب، خروجی اعلام سلامت آب\\
				
				\lr{A}:
				تست کردن آب، اعلام نتیجه آزمایش(مثلا قطع یا وصل کردن خروجی آب در صورت ناسالم بودن)\\
				\lr{S}:
				مانیتور نمایش نتیجه، کنترلر قطع و وصل، تستر سنجش کیفیت\\
				\item
				ربات تعاملی آموزش زبان\\
				\lr{P}:
				نمایش لغات مرتبط با سطح آموزنده، سرعت پردازش و نمایش لغات جدید.\\
				\lr{E}:
				آموزنده، دستگاه نمایشگر، کیبورد یا موس یا تاچ برای دریافت پاسخ آموزنده.\\
				\lr{A}:
				نمایش/پخش صوت کلمه جدید، دریافت جواب آموزنده.\\
				\lr{S}
				نمایشگر، ورودی دریافت جواب(کیبورد یا تاچ)، بلندگو\\
			\item
				ربات تنیس\\
				\lr{P}:
				رعایت قوانین بازی تنیس، برنده شدن بازی تنیس
			\\
			\lr{E}:
			راکت، توپ، زمین و محیط بازی تنیس، تور تنیس، رقیب\\
			\lr{A}:
			ضربه زدن با راکت به توپ(حرکت دادن راکت به طور کلی)، جابجایی در محدوده زمین خود\\
			\lr{S}:
			انواع دوربین‌ها(مثلا گرمایشی برای تشخیص مکان حریف)، بازو و موتور مکانیکی، شتاب سنج، سرعت سنج\\
			
				
			\end{itemize} 
	\item
	\begin{itemize}
		\item 
		کنترل کننده کیفیت آب\\
		Partially : چون هر لحظه مقداری ورودی آب دارد و برای آن مقدار می تواند اکشنی را انتخاب کند و مقادیر آینده هنوز دسترسی ندارد\\
		Single Agent\\
		Countinues\\
		Stochastic\\
		Dynamic\\
		Episodic\\
		
		\item
		ربات تعاملی آموزش زبان\\
		Partially\\
		Multi Agent\\
		Discrete :‌ هر عمل و عکس العامل مشخص و گسسته است\\
		Stochastic\\
		Dynamic\\
		Sequential\\
		
		\item
		ربات تنیس باز\\
		
		Fully Observer\\
		Multi Agent\\
		Continues\\
		Stochastic\\
		Dynamic\\
		Sequential\\
		
	\end{itemize}
	\end{enumerate}
		\item
		\begin{enumerate}
			\item 
			حالت برابر است با مجموعه مرتب موقعیت مکانی افراد\\
			حالت هدف برابر است با حالت هایی که تمام اعضای مجموعه موقعیت مکانی یکسان باشند\\
			\item
			فضای حالت برابر است با حالت های مختلف قرار داشتن افراد در نقاط مجاز نقشه که حداکثر هر فرد حداکثر
			 \lr{m*n}
			  حالت دارد حالات افراد در هم ضرب می شود و برابر است با 
			\lr{$(m\times n)^k$}
		که حالت های مجاز بازی برابر است با	
		\lr{$(m\times n - W)^k$}\\
		
		\item
		هر فرد حداکثر ۵ حرکت ممکن دارد پس موقعیت هر فرد ممکن است به یکی از ۵ حالت ممکن تغییر کند پس حالت نهایی می تواند ۵ به توان تعداد افراد نهایی حالت ممکن تغییر کند یعنی 
		\lr{$5^k$}\\
		\item
		چون هر تغییر استیت هزینه برابر ۱ واحد دارد، الگوریتم UCS همانند BFS عمل می کند و در هر گام یک واحد هزینه انجام می شود و در حالت بدبینانه ما نیاز به 
		\lr{$O(mn) \approx \frac{mn}{2}$}
		 هزینه داریم بر اساس مدلی که دیوارها چیده شده باشند، پس می تواند این تعداد بار انشعاب پیدا کند و برابر می شود با
		 \lr{$O({5^k}^\frac{mn}{2} )$} !!!\\
		 
		 \item
		 حالت اول به ازای وقتی که ۳ نفر داریم که یک نفر در وسط و دو نفر در خانه های مجاور او هستند، مقدار ۳ را خروجی می دهد(۳ زوج نقطه متفاوت داریم) اما مقدار حقیقی ۱ است، کافی است در یک گام، دو فرد طرفین، به خانه وسط بروند. پس قابل قبول نیست و سازگاری چون قابل قبول بودن را نتیجه می دهد، پس سازگار نیز نیست.\\
		 هیوریستیک دوم قابل قبول است و هم سازگار چون همواره برای رسیدن به حالت هدف، در هر گام حداکثر دو واحد می توان از فاصله منهتنی دو دورترین عضو مجموعه کم کرد، پس همواره مقدار تابع ما کوچکتر مساوی تعداد گام لازم برای رسیدن این دو فرد به نقطه مشترک است. برای سازگاری کافی است نشان دهیم هر قدم در شرط سازگاری برقرار است. می دانیم هزینه هر گام دقیقا یک واحد است و میزان هیوریستیک بعد از انجام یک عمل، حداکثر به میزان یک واحد کم می شود(میزان تغییر منهتنی دو عضو نسبت به هم حداکثر ۲ واحد تغییر می کند که نصف آن طبق فرمول می شود ۱ واحد) و در باقی حالات مقدار نصف ماکسیمم اختلاف طول یا عرض دو عضو کمتر از یک واحد تغییر می کند که یعنی همواره کمتر از هزینه آن اکشن است.\\
		 
		
		\end{enumerate}
	\item
	\begin{enumerate}
		\item
		ضریب انشعاب ۴ است چون از هر استیت(زوج مرتب نشان دهنده موقعیت روبات) می تواند در یکی از ۴ راستای مختصاتی حرکت کند.\\
		\item
		هر نقطه روی صفحه مختصات متناظر با یک استیت است.
		با k حرکت، ربات می تواند به خانه هایی که فاصله منهتنی آنها کمتر مساوی k است برسد که یعنی یک لوزی به قطر 
		\lr{2k+1}.
		 اگر محدود به یک ربع از صفحه به فضای پیمایش شده نگاه کنیم، یک مثلث قائمه که دو ضلح قائم آن 
		 \lr{k+1}
		  است داریم و تعداد نقاط درون آن برابر\\
		  
		\lr{$1+2+3+...(k+1) = \frac{(k+1)(k+2)}{2}$}
		است. پس ما ۴ مثلث داریم که در قسمت خطوط اصلی مختصات، با هم اشتراک دارند و باید تعداد 
		\lr{4k+3}
		را از حاصل کل کم کنیم(مبدا را ۴ بار شمارده ایم). پس تعداد استیت های متمایز برابر\\
		\lr{$4*\frac{(k+1)(k+2)}{2} - 4k - 3$}
		است.\\
		\item
		در bfs درختی، به اندازه ضریب انشعاب تعداد گره ها رشد می کند و الگوریتم ما در هر عمق، همه خانه هایی که تعداد گام لازم برای رسیدن به آن خانه d است را بررسی می کند. خانه مورد نظر ما در عمق x+y(فاصله منهتنی تا نقطه) است که یعنی باید به مقدار ۴ به توان این مقدار(اگر همان موقع که خانه هدف در بچه های درخت دیده شد متوقف شویم، یک واحد از توان می تواند کمتر شود) نیاز است پیمایش کنیم\\
		\lr{$4^{x+y-1}$}
		\item
		به اندازه فاصله منهتنی تا آن نقطه منهای یک (در BFS گرافی همان موقع که بچه ها را داریم به صف اضافه می کنیم، کافی است تا جواب را خروجی دهیم و نیازه به پیمایش کامل مرحله آخر نیست) که برابر است با 
		\lr{x+y-1}.
		در BFS گرافی گره های تکراری نداریم پس تا عمق
		\lr{x+y-1}
		تعداد 
		\lr{$2\times (x+y)\times (x+y+1) - 4*(x+y-1) - 3$}
		گره را مشاهده می کنیم.
		\item
		بله این تابع در اصل بهترین تابع ممکن است چون مقدار آن دقیقا میزان هزینه را نشان می دهد و هم سازگار و هم قابل قبول است چون در هر گام، رباط یک حداکثر یک واحد در کیی از جهات تغییر می کند که مقدار تابع هیوریستیک را نیز حداکثر یک واحد تغییر می دهد و هزینه هر اکشن نیز یک واحد است، پس هزینه هر اکشن از اختلاف هیوریستیک همواره بیشتر مساوی است، پس تابع سازگار است و به تبع قابل قبول است.\\
		\item
		خیر، با محدود کردن اکشن، همچنان از حالت قبل صرفا اکشن ها محدود تر شده و شروط گفته شده همچنان بر قرار می ماند.(اگر برابر یک مجموعه بزرگ خاصیتی بر قرار است، برای زیرمجموعه‌ آن نیز برقرار است).
		\item
		خیر، اگر بتواند مثلا دو واحد جابجا شود دیگر قابل قبول نیست، چون می تواند مثلا با هزینه ۱ از نقطه مبدا به هر نقطه ای برود، که این برای هر نقطه به فاصله بیشتر از ۱، دیگر شرط قابل قبول بودن را حفظ نمی کند و تابع هیوریستیک بیشتر از مقدار حقیقی هزینه می شود.\\
		 
	\end{enumerate}
\item
\begin{enumerate}
	\item 
	الگوریتم dfs گرافی اولین بچه الفبایی را انتخاب و تا زمانی که راس جدید در همان روند باشد جلو می رود که نتیجه می شود:\\
\lr{S -> B -> E -> F -> G => path = SBEFG} \\
	\item
اگوریتم BFS گرافی به تریتیب عمق جلو می رود و در هر گام بچه های راس را به انتهای صف اضافه می کند:\\
\lr{S -> B(child = {E}) -> C (child = {G}) => Path = SCG}
\item
الگوریتم UCS بر اساس هزینه صف را مرتب می کند و کمینه را بر می دارد\\
\begin{latin}
	Current State, Queue=[(State, Cost, Parent)]\\
	
	S, Queue = [(C, 1, S), (B, 2, S), (D, 10, S)]\\
	C, Queue = [(B, 2, S), (D, 10, S), (G, 16, C)]\\
	B, Queue = [(E, 9, B), (D,10, S), (G, 16, C)]\\
	E, Queue = [(D, 10, S), (F, 10, E), (G, 11, E)]\\
	D, Queue = [(F, 10, E), (G, 11, E)]\\
	F, Queue = [(G, 11, E)]\\
	G found Goal: SBEG
\end{latin}
	\item
	الگوریتم حریصانه، در هر گام کمینه فاصله هیوریستیک را انتخاب می کند.\\
	\begin{latin}
	Current State, Queue=[(State, h, Parent)]\\
	
	S, Queue = [(B, 7, S), (D, 7, S), (C, 10, S)]\\
	B, Queue = [(E, 1, B), (D, 7, S), (C, 10, S)]\\
	E, Queue = [(G, 0, E), (F, 1, E), (D, 7, S), (C, 10, S)]\\
	G found Goal: SBEG
\end{latin}
\item
\begin{itemize}
	\item 
	هر مقدار بزرگتر از صفر و کوچکتر از ۳ برای هیوریستیک D، آن را یک تابع قابل قبول می کند چون فاصله آن تا هدف، حداقل ۳ است.\\
	\item
	برای سازگار بودن(به تبع قابل قبول بودن) نیاز است که اختلاف هیوریستیک D و E کمتر از یک باشد و همچنین اختلاف هیوریستیک E از F کمتر از یک، پس هیوریستیک D حداکثر می تواند بین ۰.۵ تا ۲.۵ باشد.
\end{itemize}
\item
الگوریتم 
\lr{A*}
بر اساس کمینه هزینه کل(هزینه تا اینجا به علاوه هیوریستیک) جلو می رود. چون باید هیوریستیک قابل قبول باشد، هیوریستیک B باید کمتر مساوی ۲ باشد، هزینه تا B برابر ۲ است و هزینه تا E نیز برابر ۲پس هزینه کل برای E برابر ۳.۱ است و اگر بخواهیم B زودتر بسط یابد، هیوریستیک آن باید نامنفی و کمتر مساوی ۱.۱ باشد. و از طرفی هزینه کل برای F برابر ۳.۵ و قطعا E  زودتر بسط می یابد.\\
برای قسمت دوم باید هیوریستیک B بیشتر از ۱.۱ و کمتر مساوی از ۲ باشد تا بعد از E بسط یابد و همچنین باید مقدار هزینه کل آن کمتر از ۳.۵ باشد تا زودتر از  F بسط یابد که یعنی هیوریستیک آن باید کمتر مساوی ۱.۵ باشد. پس بازه قابل قبول برابر بیشتر از ۱.۱ و کوچکتر مساوی ۱.۵ است.\\

\end{enumerate}
\item
\begin{enumerate}
	\item 
	\begin{itemize}
		\item 

	در حالت اول که همواره مقدار true بر می گرداند به این معنی است که اگر زمانی در پیمایش به نود هدف برسد،آن را به عنوان جواب بر می گرداند، که این لزوما به معنی پیدا شدن جواب بهینه نیست، زیرا ممکن است یکی از نود ها که مسیر کوتاهی به هدف دارد به دلیل زیاد بودن بچه هایش، طول بکشد تا اکسپند شود ولی یک مسیر غیر بهینه اما کم بچه زودتر تردش تمام شود و نود هدف را پیدا کند اما بهینه نیست. در مورد کامل بودن، چون اگر مسیری وجود داشته باشد، بلاخره یک ترد نود هدف را اکسپند می کند، پس همواره کامل است و اگر مسیر وجود داشته باشد آن را پیدا می کند.\\
	\item
	کامل نیست چون ممکن است یک مسیر بیراهه که به هدف نمی رسد، تردش خیلی طول بکشد و هر بار که ما به هدف می رسیم، مقدار false می گیریم و خروجی نمی دهیم و وقتی آن ترد طولانی تمام شود، برنامه پیدا نشد را خروجی می دهد. بهینه منطقا نیست چون زمانی که جواب داریم ممکن است جواب را پیدا نکند.
	\item
		\end{itemize}
\end{enumerate}
	\end{enumerate}
\end{document}


